package mx.gob.segob.dgtic.business.rules.asistencia;


import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import mx.gob.segob.dgtic.business.service.UsuarioService;
import mx.gob.segob.dgtic.comun.sicoa.dto.AsistenciaDto;
import mx.gob.segob.dgtic.comun.sicoa.dto.UsuarioDto;
import mx.gob.segob.dgtic.persistence.repository.AsistenciaRepository;
import mx.gob.segob.dgtic.webservices.recursos.base.RecursoBase;

@Component
public class AsistenciaRules extends RecursoBase {
	
	@Autowired
	private AsistenciaRepository asistenciaRepository;
	
	@Autowired
	private UsuarioService usuarioService;
	
	public void procesaAsistencia() {

		logger.info("***** PROCESANDO ASISTENCIA *****");
		List<AsistenciaDto> listaAsistencia = filtraAsistencia();
		calculaEntradasSalidas(listaAsistencia);
		
		
		logger.info("***** TERMINA PROCESO ASISTENCIA *****");
	}
	
	/*
	 * Filtra y guarda asistencia, sólo se guarda aquella que el empleado se encuentra en nómina 
	 */
	private List<AsistenciaDto> filtraAsistencia() {
		//obtiene nómina del sistema de nómina (SIRNO)
		List<UsuarioDto> listaUsuarios = usuarioService.obtenerListaUsuarios();
		
		//obtiene asistencia del sistema de asistencias (biométricos - ASISTENCIA)
		List<AsistenciaDto> listaAsistenciaCompleta = asistenciaRepository.obtieneAsistencia();
		
		if (listaAsistenciaCompleta.size() != 0) {
			List<AsistenciaDto> listaAsistenciaFiltrada = new ArrayList<>();
			
			for (AsistenciaDto a : listaAsistenciaCompleta) {
				for (UsuarioDto u : listaUsuarios) {
					
					//id nómina de asistencias ==  id nómina de usuarios: se guarda asistencia
					if (a.getUsuarioDto().getClaveUsuario().equals(u.getClaveUsuario())) { 
						listaAsistenciaFiltrada.add(a);
					}
					
				}
			}
			
			if (listaAsistenciaFiltrada.size() != 0) {
				logger.info(listaAsistenciaFiltrada.size() + " asistencias de empleados coincidentes");
				return listaAsistenciaFiltrada;
				
			} else {
				logger.info("Entre asistencia y nómina NO se encontraron empleados coincidentes");
				return null;
			}
		} else {
			logger.info("No se encontró asistencia en el sistema de Asistencias");
			return null;
		}
		
//		asistenciaRepository.guardaAsistencia(listaAsistenciaFinal);
	}
	
	private List<AsistenciaDto> calculaEntradasSalidas(List<AsistenciaDto> listaAsistencia) {
		Set<String> hashSetIdUsuarios = new HashSet<>();
		List<UsuarioChecada> listaUsuarioChecadas = new ArrayList<>();
		List<AsistenciaDto> listaAsistenciaCalculada = new ArrayList<>();
		
		//recupera de la asistencia los id's de usuarios: sin repetidos
		for(AsistenciaDto a : listaAsistencia) {
			hashSetIdUsuarios.add(a.getUsuarioDto().getClaveUsuario());
		}
		
		//agrupa las asistencias de cada id de usuario
		for (String idUsuario : hashSetIdUsuarios) {
			UsuarioChecada usuarioChecadas = new UsuarioChecada();
			usuarioChecadas.setIdUsuario(idUsuario);
			
			for(AsistenciaDto a : listaAsistencia) {
				if (idUsuario.equals(a.getUsuarioDto().getClaveUsuario())) {
					usuarioChecadas.setListaChecadas(a.getEntrada());
				}
			}
			
			listaUsuarioChecadas.add(usuarioChecadas);
		}
		
		
		logger.info("Calculando entrada y salida de: " + listaUsuarioChecadas.size() + " empleados...");
		
		//recorre usuarios
		for (UsuarioChecada usuarioChecada : listaUsuarioChecadas) {
			AsistenciaDto asistenciaCalculada = new AsistenciaDto();
			
			UsuarioDto usuarioDto = new UsuarioDto();
			usuarioDto.setClaveUsuario(usuarioChecada.getIdUsuario());
			asistenciaCalculada.setUsuarioDto(usuarioDto);
			
			//recorre asistencia del usuario
			for (int i = 0; i < usuarioChecada.getListaChecadas().size(); i++) {
				Timestamp fechaEvento = usuarioChecada.getListaChecadas().get(i);
				Timestamp fechaEventoSiguiente = null;
				
				if (i < usuarioChecada.getListaChecadas().size() - 1) {
					fechaEventoSiguiente = usuarioChecada.getListaChecadas().get(i + 1);
				}
				
				//null: no hay evento siguiente
				if (fechaEventoSiguiente != null) {
					
					/*
					 * definición de entrada y salida
					 */
					
					//¿ocurrieron varios eventos en el mismo día? entonces se puede calcular entrada y salida
					if (fechaEvento.getYear() == fechaEventoSiguiente.getYear()) {
						if (fechaEvento.getMonth() == fechaEventoSiguiente.getMonth()) {
							if (fechaEvento.getDate() == fechaEventoSiguiente.getDate()) {
								//Eventos que sí tienen entrada y salida
								asistenciaCalculada.setSalida(fechaEvento);
							} else {
								//Evento que sólo tiene entrada
								asistenciaCalculada.setEntrada(fechaEvento);
							}
						} else {
							//Evento que sólo tiene entrada
							asistenciaCalculada.setEntrada(fechaEvento);
						}
					} else {
						//Evento que sólo tiene entrada
						asistenciaCalculada.setEntrada(fechaEvento);
					}
				}
				
//				asistenciaCalculada.setEntrada(fechaEvento);
				
				listaAsistenciaCalculada.add(asistenciaCalculada);
			}
		}
		
		for (AsistenciaDto a : listaAsistenciaCalculada) {
			
			if(a.getEntrada() != null) {
				logger.info("Id: " + a.getUsuarioDto().getClaveUsuario() + " - " + a.getEntrada());
			}
			
			if (a.getSalida() != null) {
				logger.info("Id: " + a.getUsuarioDto().getClaveUsuario() + " - " + a.getSalida());
			}
		}
		
		return listaAsistenciaCalculada;
	}

}

class UsuarioChecada {
	private String idUsuario;
	private List<Timestamp> listaChecadas = new ArrayList<>();
	
	public UsuarioChecada() {
		
	}
	
	public String getIdUsuario() {
		return idUsuario;
	}
	public void setIdUsuario(String idUsuario) {
		this.idUsuario = idUsuario;
	}
	public List<Timestamp> getListaChecadas() {
		return listaChecadas;
	}
	public void setListaChecadas(Timestamp checada) {
		this.listaChecadas.add(checada);
	}
	
	
}
